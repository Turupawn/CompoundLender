// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

// In this example, the DataTypes library is used to query the AToken address that corresponds DAI
// Later, we will use the getReserveData that will return a ReserveData object.  
// Aave docs: https://docs.aave.com/developers/core-contracts/pool#getreservedata
library DataTypes {
  struct ReserveConfigurationMap {
    uint256 data;
  }

  struct ReserveData {
    ReserveConfigurationMap configuration;
    uint128 liquidityIndex;
    uint128 currentLiquidityRate;
    uint128 variableBorrowIndex;
    uint128 currentVariableBorrowRate;
    uint128 currentStableBorrowRate;
    uint40 lastUpdateTimestamp;
    uint16 id;
    address aTokenAddress;
    address stableDebtTokenAddress;
    address variableDebtTokenAddress;
    address interestRateStrategyAddress;
    uint128 accruedToTreasury;
    uint128 unbacked;
    uint128 isolationModeTotalDebt;
  }
}

// IPool is the main AAVE interface exposed to users, the most notable functions are borrow, supply and withdraw
// AAVE docs: https://docs.aave.com/developers/core-contracts/pool
interface IPool {
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode, // 1 for Stable, 2 for Variable
        uint16 referralCode,
        address onBehalfOf) external;

    function supply(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode) external;

    function withdraw(
        address asset,
        uint256 amount,
        address to) external returns (uint256);

    function getReserveData(
        address asset) external view returns (DataTypes.ReserveData memory);
}

// ERC20 interface used to interact with the staking token, which is DAI on this tutorial
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

// This contract acts as a proxy to earn yield on AAVE. It can be used seamlessly on the background on
// a variety of contexts such as auctions, DAO treasuries, lotteries, etc...
contract AaveLender {
    // AAVE Pool Address, depolyed on Scroll Sepolia at 0x48914C788295b5db23aF2b5F0B3BE775C4eA9440
    address public immutable AAVE_POOL_ADDRESS;
    // In this example we will stake DAI, but any ERC20 supported by AAVE can be also used
    address public immutable STAKED_TOKEN_ADDRESS;
    // The AToken is a representation of the tokens we have staked, in this example is used
    // to check how much yield we have earned
    address public immutable ATOKEN_ADDRESS;
    // Only the contract owner will be able to withdraw the yield earned on AAVE
    address public immutable OWNER;
    // Mapping used to control many staking has done every user
    mapping(address account => uint amount) public stakeByAccount;
    // The totalStake is a helper variable that lets us know how much we can withdraw from the AAVE yield
    uint public totalStake;

    // We will need the AAVE Pool address and the token that will be staked, on this case the AAVE testnet DAI
    // On Scroll Sepolia those are 0x48914C788295b5db23aF2b5F0B3BE775C4eA9440 and 0x7984E363c38b590bB4CA35aEd5133Ef2c6619C40
    constructor(address aavePoolAddress, address stakedTokenAddress) {
        AAVE_POOL_ADDRESS = aavePoolAddress;
        STAKED_TOKEN_ADDRESS = stakedTokenAddress;
        OWNER = msg.sender;
        ATOKEN_ADDRESS = IPool(aavePoolAddress).getReserveData(stakedTokenAddress).aTokenAddress;
    }

    // Function that stakes DAI and lends it on the background
    function stake(uint amount) public {
        // It's always a good idea to update the state at the begining to prevent reentrancy
        totalStake += amount;
        stakeByAccount[msg.sender] += amount;
        // We start by transfering the stake to this contract
        IERC20(STAKED_TOKEN_ADDRESS).transferFrom(msg.sender, address(this), amount);
        // Next, we approve and lend on AAVE
        IERC20(STAKED_TOKEN_ADDRESS).approve(AAVE_POOL_ADDRESS, amount);
        IPool(AAVE_POOL_ADDRESS).supply(
            STAKED_TOKEN_ADDRESS,
            amount,
            address(this),
            0);
    }

    // Every user is able to unstake the exact amount it has staked, all the yield generated by AAVE will go the Owner
    function unstake(uint amount) public {
        require(amount <= stakeByAccount[msg.sender], "Not enough stake");
        totalStake -= amount;
        stakeByAccount[msg.sender] -= amount;
        // We withdraw from aave and send the tokens to the msg.sender
        IPool(AAVE_POOL_ADDRESS).withdraw(
          STAKED_TOKEN_ADDRESS,
          amount,
          msg.sender
        );
    }

    // The AToken let's us know how much we can withdraw in total. This is very useful to prevent the owner from withdrawing another's user stake
    function yieldEarned() public view returns(uint){
        return IERC20(ATOKEN_ADDRESS).balanceOf(address(this)) - totalStake;
    }

    // Only the owner can withdraw the yield generated by lending on AAVE
    // Notice how we use the AToken to know the maximum withdrawable amount, so the Owner can't withdraw the users stake
    function withdraw(uint amount) public {
        // This contract only benefits the Owner so it's not an use case by itself, but the idea can be very handy when combined with in other cases
        require(msg.sender == OWNER, "Sender is not owner");
        // The onwner can only withdraw the yield earned so every staker is able to withdraw the exact amount deposited
        require(amount <= yieldEarned(), "Maximum withdraw exceeded");
        IPool(AAVE_POOL_ADDRESS).withdraw(
          STAKED_TOKEN_ADDRESS,
          amount,
          msg.sender
        );
    }
}
